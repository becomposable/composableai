import { ContentObjectStatus, DSLActivityExecutionPayload, DSLActivitySpec } from "@becomposable/common";
import { log } from "@temporalio/activity";
import { setupActivity } from "../../dsl/setup/ActivityContext.js";
import { ActivityParamNotFound, NoDocumentFound } from "../../errors.js";



interface CreateOrUpdateObjectFromInteractionRunParams {
    /**
     * The execution run object to use. Required.
     * Not required in params since it is usually fetched
     */
    run_id?: string,
    /**
     * The document type to use. Required if updateExistingId is false.
     * Not required in params since it is usually fetched
     */
    object_type?: string,

    /**
     * The id of the document to update. If not provided, a new document will be created
     */
    updateExistingId?: string,

    fallbackName?: string, // a name to use if no one was generated by the interaction

    parent?: string, // the parent object id
}

export interface CreateOrUpdateObjectFromInteractionRun extends DSLActivitySpec<CreateOrUpdateObjectFromInteractionRunParams> {
    name: 'createOrUpdateDocumentFromInteractionRun';
}

export async function createOrUpdateDocumentFromInteractionRun(payload: DSLActivityExecutionPayload) {
    const { params, client } = await setupActivity<CreateOrUpdateObjectFromInteractionRunParams>(payload);

    const runId = params.run_id;
    const objectTypeName = params.object_type;

    if (!runId) {
        throw new ActivityParamNotFound("run_id", payload.activity);
    }
    if (!objectTypeName && !params.updateExistingId) {
        throw new ActivityParamNotFound("object_type", payload.activity);
    }

    log.info("Creating document from interaction result", { runId, objectTypeName });

    const run = await client.runs.retrieve(runId).catch((e) => {
        throw new NoDocumentFound(`Error fetching run ${runId}: ${e.message}`);
    });

    const type = objectTypeName ?
        await client.types.getTypeByName(objectTypeName).catch((e) => {
            throw new NoDocumentFound(`Error fetching type ${objectTypeName}: ${e.message}`);
        })
        : undefined;


    const result = run.result;
    const resultIsObject = typeof result === 'object';
    const inputData = run.parameters;

    let name: string;
    if (resultIsObject) {
        name = result['name'] || result["title"] || inputData['name'] || params.fallbackName || 'Untitled';
    } else {
        name = inputData['name'] || params.fallbackName || 'Untitled';
    }

    const docPayload = {
        name,
        parent: params.parent ?? undefined,
        properties: resultIsObject ? result : {},
        text: !resultIsObject ? result : undefined,
        type: type?.id,
        status: ContentObjectStatus.completed,
        generation_run_info: {
            id: run.id,
            date: new Date().toISOString(),
            model: run.modelId,
            target: resultIsObject ? 'properties' : 'text'
        }
    };

    //create or update the document
    let newDoc: boolean = false;
    let doc = undefined;
    if (params.updateExistingId) {
        log.info(`Updating existing document ${params.updateExistingId}`);
        doc = await client.objects.update(params.updateExistingId, docPayload);
    } else {
        log.info(`Creating new document of type ${objectTypeName}`);
        doc = await client.objects.create(docPayload);
        newDoc = true;
    }

    log.info(`Document ${objectTypeName + ' '}${doc.id}(${doc.name}) ${newDoc ? 'created' : 'updated'}`);
    return { id: doc.id, isNew: newDoc, type: name }
}
